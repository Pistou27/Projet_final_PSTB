<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat RAG - Projet Final GenIA</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>
    <div class="header">
        <h1>ü§ñ Assistant IA - Syst√®me RAG</h1>
        <p>Posez-moi des questions sur les documents disponibles</p>
        <div class="header-buttons">
            <button id="toggleSidebarBtn" class="header-btn" onclick="toggleSidebar()" title="Afficher/Masquer les sessions">
                üí¨ Sessions
            </button>
            <button id="statusBtn" class="header-btn" onclick="checkDocumentsStatus()">
                üìä Statut Documents
            </button>
            <button id="ingestBtn" class="header-btn" onclick="triggerIngestion()">
                üìÇ Indexer Documents
            </button>
            <button id="toggleDocsBtn" class="header-btn" onclick="toggleDocumentsSidebar()" title="Afficher/Masquer les documents">
                ÔøΩ Documents
            </button>
        </div>
    </div>

    <div class="chat-container" id="chatContainer">
        <!-- Sessions Sidebar -->
        <div class="sessions-sidebar" id="sessionsSidebar">
            <div class="sessions-header">
                <h3>üí¨ Sessions</h3>
                <button class="session-btn" onclick="toggleSessions()">‚úï</button>
            </div>
            <button class="new-session-btn" onclick="createNewSession()">
                ‚ûï Nouvelle session
            </button>
            <button class="delete-all-sessions-btn" onclick="deleteAllSessions()">
                üóëÔ∏è Supprimer toutes les sessions
            </button>
            <div class="sessions-list" id="sessionsList">
                <!-- Sessions will be loaded here -->
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="chat-main">            
            <div class="messages" id="messages">
                <div class="message assistant-message">
                    <div>üëã Bonjour ! Je suis votre assistant IA sp√©cialis√© dans l'analyse de documents.</div>
                    <div>Posez-moi des questions sur les documents disponibles et je vous r√©pondrai en fran√ßais avec les r√©f√©rences des pages sources.</div>
                </div>
            </div>

            <div class="input-container">
                <div class="input-group">
                    <input type="text" id="messageInput" placeholder="Tapez votre question ici..." maxlength="1000">
                    <button id="sendButton" disabled>Envoyer</button>
                </div>
            </div>
        </div>

        <!-- Documents Sidebar -->
        <div class="documents-sidebar" id="documentsSidebar">
            <div class="documents-header">
                <h3>üìö Documents</h3>
                <button class="docs-toggle-btn" onclick="toggleDocumentsSidebar()" title="Masquer les documents">‚úï</button>
            </div>
            <div class="documents-list" id="documentsList">
                <!-- Documents will be loaded here -->
            </div>
        </div>
    </div>

    <script>
        // Elements
        const messagesContainer = document.getElementById('messages');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const statusBtn = document.getElementById('statusBtn');
        const ingestBtn = document.getElementById('ingestBtn');
        const sessionsSidebar = document.getElementById('sessionsSidebar');
        const sessionsList = document.getElementById('sessionsList');
        const documentsSidebar = document.getElementById('documentsSidebar');
        const documentsList = document.getElementById('documentsList');

        let isLoading = false;
        let currentSessionId = null;
        let sessionsVisible = false;
        let selectedDocuments = new Set();

        // Utility function
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Show notification message
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `message assistant-message ${type}`;
            notification.innerHTML = message;
            messagesContainer.appendChild(notification);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Check documents status
        async function checkDocumentsStatus() {
            statusBtn.disabled = true;
            statusBtn.textContent = 'üîÑ V√©rification...';

            try {
                const response = await fetch('/api/ingest/status');
                const data = await response.json();

                if (data.success) {
                    // Afficher simplement la liste des documents disponibles
                    if (data.all_document_names && data.all_document_names.length > 0) {
                        const documentsList = data.all_document_names.join(', ');
                        const statusText = data.index_exists ? '‚úÖ Documents index√©s' : 'üìÑ Documents disponibles';
                        
                        const message = `üìö <strong>${statusText} :</strong><br>${documentsList}`;
                        showNotification(message, data.index_exists ? 'success' : 'info');
                    } else {
                        showNotification('üì≠ <strong>Aucun document trouv√©</strong><br>Veuillez ajouter des fichiers PDF dans le dossier data/', 'error');
                    }
                } else {
                    showNotification(`‚ùå Erreur lors de la v√©rification : ${data.message}`, 'error');
                }
            } catch (error) {
                showNotification(`‚ùå Erreur de connexion : ${error.message}`, 'error');
            } finally {
                statusBtn.disabled = false;
                statusBtn.textContent = 'üìä Statut Documents';
            }
        }

        // Trigger document ingestion
        async function triggerIngestion() {
            ingestBtn.disabled = true;
            ingestBtn.textContent = 'üîÑ Indexation...';

            showNotification('üöÄ <strong>D√©but de l\'indexation des documents...</strong><br>Cette op√©ration peut prendre quelques minutes.', 'info');

            try {
                const response = await fetch('/api/ingest', {
                    method: 'POST'
                });
                const data = await response.json();

                if (data.success) {
                    // D√©terminer le message en fonction des r√©sultats
                    const processed = data.processed_documents || 0;
                    const chunks = data.total_chunks || 0;
                    const skipped = data.stats ? data.stats.files_skipped || 0 : 0;
                    const processing_time = data.processing_time || "Non disponible";
                    
                    let message;
                    if (chunks > 0) {
                        // Cas normal: nouveaux chunks ajout√©s
                        message = `‚úÖ <strong>Indexation termin√©e avec succ√®s !</strong><br>
                            ‚Ä¢ Documents trait√©s : <strong>${processed}</strong><br>
                            ‚Ä¢ Chunks cr√©√©s : <strong>${chunks}</strong><br>
                            ‚Ä¢ Temps de traitement : <strong>${processing_time}</strong>`;
                    } else if (skipped > 0) {
                        // Cas o√π tous les documents sont d√©j√† index√©s
                        message = `‚ÑπÔ∏è <strong>Indexation termin√©e !</strong><br>
                            ‚Ä¢ Documents d√©j√† index√©s : <strong>${skipped}</strong><br>
                            ‚Ä¢ Nouveaux chunks : <strong>${chunks}</strong><br>
                            ‚Ä¢ Temps de traitement : <strong>${processing_time}</strong><br>
                            <em>Tous les documents sont d√©j√† √† jour dans l'index.</em>`;
                    } else {
                        // Cas par d√©faut
                        message = `‚úÖ <strong>Indexation termin√©e !</strong><br>
                            ‚Ä¢ Documents trait√©s : <strong>${processed}</strong><br>
                            ‚Ä¢ Chunks cr√©√©s : <strong>${chunks}</strong><br>
                            ‚Ä¢ Temps de traitement : <strong>${processing_time}</strong>`;
                    }
                    
                    showNotification(message, chunks > 0 ? 'success' : 'info');
                } else {
                    showNotification(`‚ùå Erreur lors de l'indexation : ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification(`‚ùå Erreur de connexion : ${error.message}`, 'error');
            } finally {
                ingestBtn.disabled = false;
                ingestBtn.textContent = 'üìÇ Indexer Documents';
            }
        }

        // Session Management Functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sessionsSidebar');
            const container = document.getElementById('chatContainer');
            const toggleBtn = document.getElementById('toggleSidebarBtn');
            
            console.log('Toggle sidebar called');
            console.log('Sidebar element:', sidebar);
            console.log('Container element:', container);
            console.log('Toggle button:', toggleBtn);
            
            const isHidden = sidebar.classList.contains('hidden');
            console.log('Is currently hidden:', isHidden);
            
            if (isHidden) {
                sidebar.classList.remove('hidden');
                container.classList.remove('sidebar-hidden');
                toggleBtn.innerHTML = 'üí¨ Sessions';
                localStorage.setItem('sidebarHidden', 'false');
                sessionsVisible = true;
                loadSessions();
                console.log('Sidebar shown');
            } else {
                sidebar.classList.add('hidden');
                container.classList.add('sidebar-hidden');
                toggleBtn.innerHTML = 'üí¨ Afficher';
                localStorage.setItem('sidebarHidden', 'true');
                sessionsVisible = false;
                console.log('Sidebar hidden');
            }
        }

        // Initialize sidebar state from localStorage
        function initializeSidebarState() {
            const isHidden = localStorage.getItem('sidebarHidden') === 'true';
            const sidebar = document.getElementById('sessionsSidebar');
            const container = document.getElementById('chatContainer');
            const toggleBtn = document.getElementById('toggleSidebarBtn');
            
            if (isHidden) {
                sidebar.classList.add('hidden');
                container.classList.add('sidebar-hidden');
                toggleBtn.innerHTML = 'üí¨ Afficher';
                sessionsVisible = false;
            } else {
                sessionsVisible = true;
                loadSessions();
            }
        }
        function toggleSessions() {
            sessionsVisible = !sessionsVisible;
            if (sessionsVisible) {
                sessionsSidebar.classList.remove('hidden');
                loadSessions();
            } else {
                sessionsSidebar.classList.add('hidden');
            }
        }

        async function loadSessions() {
            try {
                const response = await fetch('/api/sessions');
                const data = await response.json();

                if (data.success) {
                    displaySessions(data.sessions);
                } else {
                    console.error('Error loading sessions:', data.error);
                }
            } catch (error) {
                console.error('Error loading sessions:', error);
            }
        }

        function displaySessions(sessions) {
            sessionsList.innerHTML = '';
            
            if (sessions.length === 0) {
                sessionsList.innerHTML = '<div style="padding: 1rem; text-align: center; color: #6c757d;">Aucune session trouv√©e</div>';
                return;
            }

            sessions.forEach(session => {
                const sessionDiv = document.createElement('div');
                sessionDiv.className = `session-item ${session.session_id === currentSessionId ? 'active' : ''}`;
                sessionDiv.onclick = () => selectSession(session.session_id);

                const lastActivity = new Date(session.last_activity).toLocaleDateString('fr-FR', {
                    day: '2-digit',
                    month: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                sessionDiv.innerHTML = `
                    <div class="session-title">${session.title || 'Session sans titre'}</div>
                    <div class="session-meta">
                        ${session.message_count} messages ‚Ä¢ ${lastActivity}
                        <button class="session-btn delete" onclick="event.stopPropagation(); deleteSession('${session.session_id}')">
                            üóëÔ∏è
                        </button>
                    </div>
                `;

                sessionsList.appendChild(sessionDiv);
            });
        }

        async function createNewSession() {
            try {
                const sessionId = 'session_' + Date.now();
                const response = await fetch('/api/sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        session_id: sessionId,
                        title: 'Nouvelle conversation'
                    })
                });

                const data = await response.json();

                if (data.success) {
                    currentSessionId = sessionId;
                    clearMessages();
                    loadSessions();
                    showNotification('‚úÖ Nouvelle session cr√©√©e !', 'success');
                } else {
                    showNotification(`‚ùå Erreur lors de la cr√©ation : ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification(`‚ùå Erreur de connexion : ${error.message}`, 'error');
            }
        }

        async function selectSession(sessionId) {
            if (sessionId === currentSessionId) return;

            currentSessionId = sessionId;
            clearMessages();
            
            try {
                const response = await fetch(`/api/sessions/${sessionId}/history`);
                const data = await response.json();

                if (data.success) {
                    loadSessionHistory(data.history);
                    loadSessions(); // Refresh to update active state
                    showNotification(`üìÇ Session charg√©e (${data.history.length} messages)`, 'info');
                } else {
                    showNotification(`‚ùå Erreur lors du chargement : ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification(`‚ùå Erreur de connexion : ${error.message}`, 'error');
            }
        }

        async function deleteSession(sessionId) {
            if (!confirm('√ätes-vous s√ªr de vouloir supprimer cette session ?')) return;

            try {
                const response = await fetch(`/api/sessions/${sessionId}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    if (sessionId === currentSessionId) {
                        currentSessionId = null;
                        clearMessages();
                    }
                    loadSessions();
                    showNotification('‚úÖ Session supprim√©e !', 'success');
                } else {
                    showNotification(`‚ùå Erreur lors de la suppression : ${data.error}`, 'error');
                }
            } catch (error) {
                showNotification(`‚ùå Erreur de connexion : ${error.message}`, 'error');
            }
        }

        async function deleteAllSessions() {
            if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir supprimer TOUTES les sessions ? Cette action est irr√©versible !')) return;

            const deleteAllBtn = document.querySelector('.delete-all-sessions-btn');
            deleteAllBtn.disabled = true;
            deleteAllBtn.textContent = 'üîÑ Suppression...';

            try {
                // First, get all sessions
                const sessionsResponse = await fetch('/api/sessions');
                const sessionsData = await sessionsResponse.json();

                if (!sessionsData.success) {
                    throw new Error('Impossible de r√©cup√©rer la liste des sessions');
                }

                const sessions = sessionsData.sessions;
                if (sessions.length === 0) {
                    showNotification('‚ÑπÔ∏è Aucune session √† supprimer.', 'info');
                    return;
                }

                // Delete each session
                let deletedCount = 0;
                let errors = 0;

                for (const session of sessions) {
                    try {
                        const response = await fetch(`/api/sessions/${session.session_id}`, {
                            method: 'DELETE'
                        });

                        const data = await response.json();
                        if (data.success) {
                            deletedCount++;
                        } else {
                            errors++;
                        }
                    } catch (error) {
                        errors++;
                    }
                }

                // Reset current session
                currentSessionId = null;
                clearMessages();
                
                // Refresh sessions list
                loadSessions();

                // Show result notification
                if (errors === 0) {
                    showNotification(`‚úÖ Toutes les sessions ont √©t√© supprim√©es ! (${deletedCount} sessions)`, 'success');
                } else {
                    showNotification(`‚ö†Ô∏è ${deletedCount} sessions supprim√©es, ${errors} erreurs.`, 'error');
                }

            } catch (error) {
                showNotification(`‚ùå Erreur lors de la suppression : ${error.message}`, 'error');
            } finally {
                deleteAllBtn.disabled = false;
                deleteAllBtn.textContent = 'üóëÔ∏è Supprimer Toutes les Sessions';
            }
        }

        function loadSessionHistory(history) {
            // Add welcome message first
            addMessage('üëã Bonjour ! Je suis votre assistant IA sp√©cialis√© dans l\'analyse de documents.<br>Posez-moi des questions sur les documents disponibles et je vous r√©pondrai en fran√ßais avec les r√©f√©rences des pages sources.', 'assistant');

            // Load conversation history
            history.forEach(exchange => {
                addMessage(exchange.user_message, 'user');
                addMessage(exchange.assistant_response, 'assistant', exchange.sources);
            });
        }

        function clearMessages() {
            messagesContainer.innerHTML = '';
            // Add default welcome message
            addMessage('üëã Bonjour ! Je suis votre assistant IA sp√©cialis√© dans l\'analyse de documents.<br>Posez-moi des questions sur les documents disponibles et je vous r√©pondrai en fran√ßais avec les r√©f√©rences des pages sources.', 'assistant');
        }

        // Documents Management Functions
        function toggleDocumentsSidebar() {
            const toggleBtn = document.getElementById('toggleDocsBtn');
            const isHidden = documentsSidebar.classList.toggle('hidden');
            
            if (isHidden) {
                toggleBtn.innerHTML = 'üìö Afficher';
                toggleBtn.title = 'Afficher les documents';
            } else {
                toggleBtn.innerHTML = 'üìö Documents';
                toggleBtn.title = 'Masquer les documents';
            }
        }

        async function loadDocuments() {
            try {
                const response = await fetch('/api/ingest/status');
                const data = await response.json();

                if (data.success && data.document_names) {
                    displayDocuments(data.document_names);
                    // Select only the first document by default
                    selectedDocuments.clear();
                    if (data.document_names.length > 0) {
                        selectedDocuments.add(data.document_names[0].filename);
                    }
                    updateDocumentSelection();
                } else {
                    documentsList.innerHTML = '<div style="padding: 1rem; text-align: center; color: #6c757d;">Aucun document trouv√©</div>';
                }
            } catch (error) {
                console.error('Error loading documents:', error);
                documentsList.innerHTML = '<div style="padding: 1rem; text-align: center; color: #dc3545;">Erreur de chargement</div>';
            }
        }

        function displayDocuments(documents) {
            documentsList.innerHTML = '';
            
            documents.forEach(doc => {
                const docDiv = document.createElement('div');
                docDiv.className = 'document-item';
                docDiv.onclick = () => toggleDocumentSelection(doc.filename);

                const isSelected = selectedDocuments.has(doc.filename);
                
                // Create embedding models display
                let embeddingInfo = '';
                if (doc.embedding_models && doc.embedding_models.length > 0) {
                    const embeddingList = doc.embedding_models.map(model => {
                        // Show more descriptive model names
                        if (model.includes('all-MiniLM-L6-v2')) return 'MiniLM-L6-v2';
                        if (model.includes('bge-m3')) return 'BGE-M3';
                        if (model.includes('BAAI/bge-m3')) return 'BGE-M3';
                        if (model.includes('sentence-transformers/all-MiniLM-L6-v2')) return 'MiniLM-L6-v2';
                        // For other models, show the last part but keep it more descriptive
                        const parts = model.split('/');
                        return parts[parts.length - 1] || model;
                    }).join(', ');
                    embeddingInfo = `<div class="document-embeddings">üîó ${embeddingList}</div>`;
                } else {
                    embeddingInfo = '<div class="document-embeddings no-embeddings">‚ùå Non index√©</div>';
                }
                
                docDiv.innerHTML = `
                    <div class="document-header">
                        <input type="checkbox" class="document-checkbox" ${isSelected ? 'checked' : ''} 
                               onchange="toggleDocumentSelection('${doc.filename}')">
                        <div class="document-name">${doc.display_name}</div>
                        <div class="document-status ${doc.has_embeddings ? 'embedded' : 'not-embedded'}">
                            ${doc.has_embeddings ? '‚úÖ' : '‚ùå'}
                        </div>
                    </div>
                    ${embeddingInfo}
                `;

                if (isSelected) {
                    docDiv.classList.add('selected');
                }

                documentsList.appendChild(docDiv);
            });
        }

        function toggleDocumentSelection(filename) {
            // Clear all selections first (radio button behavior)
            selectedDocuments.clear();
            // Add only the clicked document
            selectedDocuments.add(filename);
            updateDocumentSelection();
        }

        function updateDocumentSelection() {
            const checkboxes = documentsList.querySelectorAll('.document-checkbox');
            const items = documentsList.querySelectorAll('.document-item');
            
            checkboxes.forEach((checkbox, index) => {
                const item = items[index];
                const filename = checkbox.closest('.document-item').querySelector('.document-name').textContent;
                
                // Find the actual filename from display name
                let actualFilename = '';
                document.querySelectorAll('.document-item').forEach(docItem => {
                    const displayName = docItem.querySelector('.document-name').textContent;
                    if (displayName === filename) {
                        actualFilename = docItem.querySelector('.document-checkbox').onchange.toString().match(/'([^']+)'/)[1];
                    }
                });
                
                const isSelected = selectedDocuments.has(actualFilename);
                checkbox.checked = isSelected;
                item.classList.toggle('selected', isSelected);
            });

            console.log('Selected documents:', Array.from(selectedDocuments));
        }

        // Enable/disable send button
        function updateSendButton() {
            const hasText = messageInput.value.trim().length > 0;
            sendButton.disabled = !hasText || isLoading;
        }

        // Add message to chat
        function addMessage(content, type, sources = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            // Generate unique ID for this message
            const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            messageDiv.id = messageId;
            
            let messageContent = '';
            if (type === 'user') {
                messageContent = escapeHtml(content);
            } else {
                messageContent = content; // Assistant messages can contain HTML/Markdown
            }
            
            messageDiv.innerHTML = messageContent;

            // Add sources if provided
            if (sources && sources.length > 0) {
                const sourcesDiv = document.createElement('div');
                sourcesDiv.className = 'sources';
                sourcesDiv.innerHTML = '<strong>üìö Sources :</strong><br>' + 
                    sources.map((source, index) => 
                        `<div class="source-item">
                            <div class="source-header" onclick="toggleSource('${messageId}_src_${index}')">
                                <span>‚Ä¢ ${source.document} (page ${source.page})</span>
                                <span class="source-toggle">‚ñº</span>
                            </div>
                            <div class="source-content" id="${messageId}_src_${index}" style="display: none; margin-left: 20px; margin-top: 5px; padding: 10px; background-color: #f5f5f5; border-radius: 5px; font-size: 0.9em; color: #555;">
                                ${source.content_preview || 'Contenu non disponible'}
                            </div>
                        </div>`
                    ).join('');
                messageDiv.appendChild(sourcesDiv);
            }

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Send message
        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || isLoading) return;

            // Add user message
            addMessage(message, 'user');
            messageInput.value = '';
            updateSendButton();

            // Set loading state
            isLoading = true;
            updateSendButton();
            
            // Add loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.className = 'message assistant-message loading';
            loadingDiv.textContent = 'ü§î Je r√©fl√©chis...';
            loadingDiv.id = 'loading-message';
            messagesContainer.appendChild(loadingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        session_id: currentSessionId,
                        selected_documents: Array.from(selectedDocuments)
                    })
                });

                // Remove loading indicator
                const loadingElement = document.getElementById('loading-message');
                if (loadingElement) {
                    loadingElement.remove();
                }

                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const data = await response.json();
                
                // Debug logging to see what we're actually receiving
                console.log('API Response:', data);

                // Check if we have a valid response (API returns 'response' field when successful)
                if (data.response) {
                    // Update current session ID if it was created
                    if (data.session_id && !currentSessionId) {
                        currentSessionId = data.session_id;
                        loadSessions(); // Refresh sessions list
                    }
                    
                    addMessage(data.response, 'assistant', data.sources);
                } else {
                    // Handle error case (API returns 'error' field when there's an error)
                    addMessage(`‚ùå Erreur: ${data.error || 'Unknown error'}`, 'assistant');
                    console.log('Error details:', data);
                }

            } catch (error) {
                // Remove loading indicator
                const loadingElement = document.getElementById('loading-message');
                if (loadingElement) {
                    loadingElement.remove();
                }
                
                console.error('Erreur:', error);
                addMessage(`‚ùå Erreur de connexion: ${error.message}`, 'assistant');
            } finally {
                isLoading = false;
                updateSendButton();
            }
        }

        // Event listeners
        messageInput.addEventListener('input', updateSendButton);
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        sendButton.addEventListener('click', sendMessage);

        // Function to toggle source content visibility
        window.toggleSource = function(sourceId) {
            const sourceContent = document.getElementById(sourceId);
            const toggle = sourceContent.previousElementSibling.querySelector('.source-toggle');
            
            if (sourceContent.style.display === 'none') {
                sourceContent.style.display = 'block';
                toggle.textContent = '‚ñ≤';
                toggle.style.transform = 'rotate(180deg)';
            } else {
                sourceContent.style.display = 'none';
                toggle.textContent = '‚ñº';
                toggle.style.transform = 'rotate(0deg)';
            }
        };

        // Initialize
        updateSendButton();
        messageInput.focus();
        
        // Initialize sidebar state and load sessions if visible
        initializeSidebarState();
        
        // Load documents list
        loadDocuments();
    </script>
</body>
</html>
